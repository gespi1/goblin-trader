package common

import (
	"fmt"
	"image/color"
	"math"

	"github.com/sdcoffey/techan"
	log "github.com/sirupsen/logrus"
	"gonum.org/v1/plot"
	"gonum.org/v1/plot/plotter"
)

// returns values generated by an indicator
func Dump(indicator techan.Indicator) (values []float64) {
	precision := 4.0
	m := math.Pow(10, precision)

	defer func() {
		recover()
	}()

	var index int
	for {
		values = append(values, math.Round(indicator.Calculate(index).Float()*m)/m)
		index++
	}

	return
}

// return XYs for any x, y []float64 of the same length
func MakeXYs(x, y []float64) (plotter.XYs, error) {
	var XYs plotter.XYs
	if len(x) == len(y) {
		log.Debug("x and y match length. Creating X and Y points for graph")

		for i, _ := range x {
			XYs = append(XYs, plotter.XY{X: x[i], Y: y[i]})
		}

		return XYs, nil
	} else {
		return nil, fmt.Errorf("MakeXYs | x:( %v )and y:( %v ) DON'T match length", x, y)
	}

}

// return []XYs for lowerband and upperband
func MakeBandXYs(x, y []float64) ([]plotter.XYs, error) {
	var XYs plotter.XYs
	var lines []plotter.XYs
	if len(x) == len(y) {
		log.Debug("x and y match length. Creating X and Y points for graph")

		for i, _ := range x {
			if y[i] == math.NaN() { // this means the plot is NaN. Create a new line
				lines = append(lines, XYs)
				XYs = plotter.XYs{}
			} else {
				XYs = append(XYs, plotter.XY{X: x[i], Y: y[i]})
			}
		}

		return lines, nil
	} else {
		return nil, fmt.Errorf("MakeBandXYs | x:( %v )and y:( %v ) DON'T match length", x, y)
	}

}

func AddBandLineXYs(LXYs []plotter.XYs, p *plot.Plot, c color.RGBA) (*plot.Plot, error) {
	for _, xys := range LXYs {
		l, err := plotter.NewLine(xys)
		if err != nil {
			return nil, err
		}
		l.Color = c
		p.Add(l)
	}

	return p, nil
}
